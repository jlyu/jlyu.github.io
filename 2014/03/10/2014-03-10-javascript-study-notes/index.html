<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript 学习笔记 · Chain's Blog</title><meta name="description" content="JavaScript 学习笔记 - Chain Yu"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jlyu.github.io/atom.xml" title="Chain's Blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript 学习笔记</h1><div class="post-info">Mar 10, 2014</div><div class="post-content"><p><strong>JavaScript</strong>是一种非类型的(?)，松类型，弱类型(?)，动态类型。脚本语言。 并基于原型的继承，是一种真正的OO语言。非惰性求值。语言不同分类间相互衍生的产物：同时是说明式和命令式，并同时具有函数式特性，命令式（基于原型的面向对象和过程）的特性弱类型，表明该语言在表达式运算中不强制校验运算元的数据类型，不表明语言是否具有类型系统。</p>
<a id="more"></a>
<p>1.赋值是一个运算，而不是一个语句。<br>2.赋值运算的本质：修改存储单元中的值<br>3.JavaScript 中只有一种方法来完成函数调用，即在函数后紧临函数调用运算符()<br>4.引用，在JavaScript中只是表示传递给函数的是对象或数组的引用（地址），而不是对象自身。但是在函数内部中改变的数值不会影响函数传入的参数本身。<br>5.JavaScript中字符串无法修改，通过传值来比较<br>6.var声明的变量是永久性的，用delete删除会引发错误<br>7.没有块级作用域。函数中声明的所有变量在整个函数体内都有定义。<br>8.将所有的变量声明在函数开头。<br>9.全局变量是全局对象的属性；局部变量是一个特殊的调用对象的属性<br>10.作用域链 （scope chain）  &lt;=事件冒泡?<br>查询某个变量的值时触发变量名解析（variable name resolution）<br>    顶层代码 scope chain=全局变量<br>    函数（不含嵌套） scope chain=调用对象+全局变量<br>    嵌套函数 scope chain=3+<br>11.使用了GC，垃圾收集机制<br>12.delete影响属性值，并不影响这些属性引用的对象。<br>13.void总是舍弃运算数的值然后返回undefined<br>14.switch匹配的case是用===完全等同运算符判定的，而不是用==相等运算符判定<br>15.函数function定义在解析时发生，而不是在运行时发生<br>16.with语句用于暂时修改作用域链 （速度慢，难优化）</p>
<p><strong>function</strong><br>了解 JavaScript Function 的一切了。Function 的本质是什么，什么是 closure，如何用 Function.prototype.apply 改变 this，为什么要改变 prototype 引用。如果这些问题有一个你搞不明白，你都写不出 Function.prototype.bind。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">      <span class="keyword">var</span> fn = <span class="keyword">this</span>, </span><br><span class="line">            args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>), </span><br><span class="line">            object = args.shift();  </span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">            <span class="keyword">return</span> fn.apply(object, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));  </span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>JavaScript 中只有一种方法来完成函数调用，即在函数后紧临函数调用运算符()<br><strong>匿名函数调用</strong><br>(function() {}());  // 返回调用结果<br>(function() {})();  // 返回函数自身<br>void function(){} (); // 调用函数并忽略返回值<br>永远不可能在JavaScript中通过修改参数来影响到函数外部的变量<br><strong>动态方法调用</strong><br>要将一个普通函数作为一个对象的方法调用，或者将A对象的方法作为B对象的方法调用，唯一要做的，也仅是改变一下this引用。<br>call 和 apply<br>     Area.prototype.doCalc = function( ) {<br>          calc_area.apply(this, arguments); //calc_area非Area方法<br>     }</p>
<p><strong>Scope</strong><br>没有块级作用域。函数中声明的所有变量在整个函数体内都有定义。<br>建议将所有的变量声明在函数开头。<br>全局变量是全局对象的属性；局部变量是一个特殊的调用对象的属性<br><strong>变量作用域</strong>：代码执行阶段对变量存储的理解。只有表达式，局部和全部3种作用域。生存周期只有2个：函数内的局部执行期间和函数外引擎的全局执行期间。将对象（类）的继承关系，与对象（类）的行为描述分离，只能依赖“变量作用域”来实现OO的封装特性<br><strong>语法作用域</strong>：语法分析阶段对代码块组织结构的理解。互不相交，可以存在平行或包含关系。高级别可以嵌套低级别的语法作用域，反之不成立；高级别的流程变更子句（或语句）可以跨越低级别的作用域：全局 &gt; 函数 &gt; 批语句 &gt; 语句 &gt; 表达式。</p>
<p><strong>Closure</strong><br>函数闭包：函数代码在运行过程中的一个动态环境。<br>对象闭包：with语句实现<br>闭包是运行期概念。<br>闭包是对应于运行期的函数实例的，而不是对应函数（代码块）的。<br>每一个函数实例都有一份<br>eval()<br>不同JavaScript引擎对eval()所使用的闭包环境的理解并不相同。<br>一般来说，eval()总是使用当前函数的闭包。<br>JavaScript的执行 动态执行 -&gt; 不能真实编译的，指编译成为二进制<br>     代码文本先被解释为语法树，然后按照语法树来执行的<br>     每次执行语法树中的一个函数（实例）时，会复制一个结构scriptObject。包含函数相关的形式参数，函数局部变量，upvalue，内层函数嵌套信息<br>     scriptObject动态关联到一个闭包，闭包与scriptObject具有不同的生存周期。<br>     按语法树执行函数中的代码，当访问变量时，先查scriptObject中的局部变量，最后查upvalue<br>函数在定义它的作用域内被执行，而不是在调用它的作用域里被执行。嵌套函数可以访问包含函数的所有参数和局部变量。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="comment">// code goes here.</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">uniqueID = ( <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; id++; &#125;;</span><br><span class="line">&#125; )();</span><br></pre></td></tr></table></figure></p>
<p>理解变量作用域是理解闭包的第一步  </p>
<p><strong>arguments</strong><br>是一个类似数组的对象,并非真正的数组。<br>只是一个普通的js标识符，不是保留字。<br>一旦函数内有变量名为arguments则会隐藏对arguments对象的引用<br>作用：</p>
<pre><code>1. 检测是否使用了正确的参数个数
2. 能写可变参数函数 
</code></pre><p>arguments改变也会影响传入的参数<br><strong>arguments.callee</strong><br>属性可以让匿名函数递归调用自身<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (x&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">return</span> x * <span class="built_in">arguments</span>.callee(x<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>this</strong><br>this作为函数内部的一个对象。谁调用函数，this就指向调用者本身。<br>由于late-banding导致this的指向具有迷惑性。<br>任何用作方法（obj.func = method）的函数都被有效地传递了一个隐式的参数this；不允许为this赋值</p>
<p><strong>OO</strong><br>JavaScript不会有一个正式的类名字，它只是通过构造函数及其原型对象来近似地模拟类。<br>所有的函数都有一个prototype属性。js对象从它的原型继续属性。<br>使用原型对象可以显著减少每个对象所需的内存数量。<br>对象实例初始化：<br>     通过在构造器中利用this引用来初始化<br>     通过构造原型实例来初始化<br>     通过Object.create()并使用属性描述符的方式来构建对象并初始化<br>实例属性，是由构造函数创建和初始化的属性<br>每个实例方法由一个类的所有实例来共享。必须为属性显式指定 this 关键字<br>类属性，类的每个属性都只有一份拷贝。全局的。Rectangle.UNIT = new Rectangle(1,1);<br>类方法，通过类自身调用，非类的一个具体实例调用，不使用this。也是全局的。 Date.parse()<br>空对象 null 属于对象类型，对象是空值<br>空的对象 obj=new Object(); obj={ };<br>直接量 Literals（undefined, null, true/false, 数值，字符串，正则）的声明中不包含运算过程；<br>初始器 Initialiser 的声明中是可以包括运算过程的。<br>取一个不存在的属性的值不会导致异常，而是返回undefined<br>或者通过 if(typeof (obj.prop) != ‘undefined’) 来判断 （还是会存在obj.prop=’undefined’ 特例<br>或者通过 obj instanceof myobject<br>propertyIsEnumerable() 被标准强制实现成“只检测对象的非（自原型链继承而来的）继承属性”</p>
<p><strong>namespace</strong><br>新建一个空对象作为名称空间<br>var Class = {};<br>Class.define = …<br>一个模块不应该为全局名称空间添加多于一条的标记<br>使用个人域名作为名称空间 com.chaindomain.Class<br>var com;<br>if (!com) com={};<br>else if (typeof com != ‘object’)<br>     throw new Error(“com already exists and is not an object.”);<br>名称空间导入标记<br>var defineClass = com.chaindomain.define; //避免了冗长的模块名称<br>或在模块内部继续<br>var Class = {};<br>Class.define =  com.chaindomain.define;</p>
<p><strong>delete</strong><br>     不能delete var 声明的变量<br>     不能delete 直接继承自原型的成员。会恢复到prototype的值<br>     仅在删除一个不能删除的成员时，才会返回false<br>     delete book.chapter2 不仅置undefined和null,而且移除属性，in也不会检测到了。for..in..</p>
<h4 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h4><p>对象 {}<br>对象的另一种解释是：一个无序的属性集合。<br>通常用var来声明变量，但在声明对象的属性却不能使用。 book.title=”The Guide of JavaScripte”;<br>!== 和 != 的区别在于undefined 和 null</p>
<p>obj.property 和 obj[‘property’] 的区别<br>后者更灵活。for (var i=0; i &lt; 4; i++) { addr += obj[‘property’ + i]; } </p>
<p>constructor属性可确定一个对象的类型<br>d.constructor == Date 也可以写成 d instanceof Date<br>toString()       toLocaleString()<br>valueOf()<br>hasOwnProperty() 非继承的自有属性<br>propertyIsEnumerable() 非继承的自有属性，且此属性可以在for-in中被枚举<br>isPrototypeOf() 判断对象是否是参数的原型对象</p>
<p>数组 []<br>数组不过是一个有额外功能层的对象<br>创建数组</p>
<ol>
<li>var arr = [1,2,3];</li>
<li>var arr = new Array();</li>
<li>var arr = new Array(1,2,3);</li>
<li>var arr = new Array(10);<br>index 必须是0~2^32-1的整数，不然会变成生成对象的新属性<br>length 总是比数组最大元素的数大1<br>删除数组<br>Array.shift()<br>Array.pop()<br>Array.splice()<br>遍历数组<br>for (var i=0; i &lt; arr.length; i++) { … }  // 前提 arr 是连续数组<br>push() pop()<br>unshift() shift()</li>
</ol>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数最重要的特性是他们可以被定义和调用。<br>最后return可有可无。无，相当于return undefined<br>用 typeof 进行类型检测 a = a || []<br>arguments对象是一个类似数组的对象,并非真正的数组.只是一个普通的js标识符，不是保留字。一旦函数内有变量名为arguments则会隐藏对arguments对象的引用<br>作用：</p>
<pre><code>1. 检测是否使用了正确的参数个数
2. 能写可变参数函数 
</code></pre><p>arguments改变也会影响传入的参数<br>arguments.callee属性可以让匿名函数递归调用自身<br>function(x) {<br>     if (x&lt;=1) return 1;<br>     return x * arguments.callee(x-1);<br>}</p>
<p>如果一个函数参数过多，可以通过在函数外wrapper一层函数，然后传对象的方式传递<br>easycopy ({from:a, to:b, length:4});<br>任何用作方法（obj.func = method）的函数都被有效地传递了一个隐式的参数this；不允许为this赋值</p>
<p>prototype属性<br>引用的是预定义的原型对象。</p>
<p>call()   =&gt; f.call(o, 1,2);<br>apply() 与call() 相似，只是传递的参数由数组组成 f.apply(o, [1,2]);<br>第一个参数都是要调用的函数的对象</p>
<h4 id="构造函数和原型对象"><a href="#构造函数和原型对象" class="headerlink" title="构造函数和原型对象"></a>构造函数和原型对象</h4><p>自定义构造函数<br>function Rectangle(w,h) {<br>     this.width = w;<br>     this.height = h;</p>
<pre><code>this.area = function() { return this.width * this.height; }  // 这样效率很低 why? 因为每份实例都要定义自己的area方法呀。使用原型对象可以显著减少每个对象所需的内存数量。
Rectange.prototype.area = function() { ... } 
</code></pre><p>}</p>
<p>所有的函数都有一个prototype属性。js对象从它的原型继续属性。<br>使用原型对象可以显著减少每个对象所需的内存数量。<br>在对象创建以后才添加到原型中的属性，对象也可以继承。<br>prototype属性是由一个类的所有对象共享的属性，prototype是理想的定义方法的工具；同样，常量也适用prototype</p>
<p>JavaScript不会有一个正式的类名字，它只是通过构造函数及其原型对象来近似地模拟类<br>实例属性，是由构造函数创建和初始化的属性<br>每个实例方法由一个类的所有实例来共享。必须为属性显式指定 this 关键字<br>类属性，类的每个属性都只有一份拷贝。全局的。Rectangle.UNIT = new Rectangle(1,1);<br>类方法，通过类自身调用，非类的一个具体实例调用，不使用this。也是全局的。 Date.parse()</p>
<p>比较方法 a.compareTo(b)<br>按地址比较对象，而不是按值.</p>
<p>超类和子类<br>显示调用超类的构造函数，叫做构造函数链</p>
<p>Rectangle.call(this, w, h); 可以简化成</p>
<p>PositionedRectangle.prototype.superClass = Rectangle;<br>this.Rectangle(w, h);<br>超类构造函数通过this对象被显式调用，就不再要使用call或apply。但要注意子类的子类情况。也就是说superclass属性只能在继承层次中用1次。</p>
<p>混入类 mixin class<br>只定义其他类可以借用的有用方法，除此以外什么也没做。</p>
<p>判定对象类型<br>typeof   注意：typeof null == typeof undefined == ‘object’<br>instanceof   o instanceof object || function 总是true<br>toString() 只对内建对象类型有效，那么 Object.prototype.toString.apply(o);</p>
<h4 id="名称空间和初始化"><a href="#名称空间和初始化" class="headerlink" title="名称空间和初始化"></a>名称空间和初始化</h4><p>新建一个空对象作为名称空间</p>
<p>var Class = {};<br>Class.define = …</p>
<p>一个模块不应该为全局名称空间添加多于一条的标记</p>
<p>那如果名称冲突的js文件，通过在不同子目录下的存放动作是否可以避免冲突了？<br>这也就是为何提成js模块化编程</p>
<p>使用个人域名作为名称空间 com.chaindomain.Class</p>
<p>var com;<br>if (!com) com={};<br>else if (typeof com != ‘object’)<br>     throw new Error(“com already exists and is not an object.”);</p>
<p>名称空间导入标记<br>var defineClass = com.chaindomain.define; //避免了冗长的模块名称<br>或<br>在模块内部继续<br>var Class = {};<br>Class.define =  com.chaindomain.define;</p>
<p>闭包定义私有空间<br>语法错误：<br>     语法分析通不过，整个脚本代码块都不执行。<br>     语法分析通过后，但在执行过程中出错，那么在同一代码上下文中，出错点后的代码将不再执行。</p>
<p>全局变量：在函数外声明的变量<br>局部变量：在函数或子函数内声明的变量。</p>
<p>通过 typeof 获得对象6种类型（first-class）之一：undefined, number, string, boolean ｜ function, object</p>
<p>显式声明：var<br>隐式声明：不用var </p>
<p>=== 如果不是同一个变量或其引用，则2个变量不相等，也不相同。</p>
<p>finally { … } 总是在try/catch块退出之前被执行，但“不一定”能被完整地执行（在finally里面又发生异常或者throw）</p>
<p>二义性</p>
<ul>
<li>如果表达式中存在字符串，则优先按字符串连接进行运算<br>（） 虚拟参数表<br> 传值参数表<br> 充当if, while和do…while语句中的词法元素时，（）会有”将表达式结果转换为布尔值”的副作用<br> 强制表达式运算<br>[ ]   可以理解为数组声明或下标存取<br> 可以理解为对象成员存取</li>
</ul>
<p>语法作用域：语法分析阶段对代码块组织结构的理解<br>互不相交，可以存在平行或包含关系。高级别可以嵌套低级别的语法作用域，反之不成立；高级别的流程变更子句（或语句）可以跨越低级别的作用域<br>全局 &gt; 函数 &gt; 批语句 &gt; 语句 &gt; 表达式</p>
<p>变量作用域：代码执行阶段对变量存储的理解。只有表达式，局部和全部3种作用域。生存周期只有2个：函数内的局部执行期间和函数外引擎的全局执行期间。</p>
<p>空对象 null 属于对象类型，对象是空值<br>空的对象 obj=new Object(); obj={ };<br>属性&lt;构造器&gt;.prototype指向原型。对象只有“构造自某个原型”的问题，并不存在“持有某个原型”的问题<br>原型也是对象实例</p>
<p>将对象（类）的继承关系，与对象（类）的行为描述分离<br>只能依赖“变量作用域”来实现OO的封装特性</p>
<p>函数式语言 （连续求值）<br>这里的函数，指的是：函数 == “lambda”<br>     +函数是运算元<br>     +函数内保存数据<br>               JavaScript中的函数作为参数时，也是传递引用的。但没有地址概念<br>               函数语言可以在函数内保存数据。在命令式语言中，函数内部的私有变量（局部变量）是不能被保存的<br>     +函数内的运算对函数外无副作用<br>               函数入口参数作为值参数，而不修改它<br>               在运算过程中不会修改函数外部其他数据的值（如全局函数）<br>               运算结束后通过函数返回向外部系统传值<br>永远不可能在JavaScript中通过修改参数来影响到函数外部的变量</p>
<p>包装类<br>在元数据经过“包装类”包装后得到的对象，与原来的元数据并不再是同一数据，只是二者的值相等而已。</p>
<h4 id="参考书目"><a href="#参考书目" class="headerlink" title="参考书目"></a>参考书目</h4><ul>
<li>蝴蝶书 《JavaScript: The Good Parts》  <a href="http://book.douban.com/subject/2994925/" target="_blank" rel="noopener">http://book.douban.com/subject/2994925/</a></li>
<li>犀牛书 《JavaScript权威指南》<a href="http://book.douban.com/subject/2228378/" target="_blank" rel="noopener">http://book.douban.com/subject/2228378/</a></li>
<li>《JavaScript Cookbook》<a href="http://book.douban.com/subject/4720800/" target="_blank" rel="noopener">http://book.douban.com/subject/4720800/</a></li>
<li>《JavaScript语言精髓与编程实践》<a href="http://book.douban.com/subject/10542576/" target="_blank" rel="noopener">http://book.douban.com/subject/10542576/</a></li>
<li>《Effective JavaScript》<a href="http://book.douban.com/subject/10494340/" target="_blank" rel="noopener">http://book.douban.com/subject/10494340/</a></li>
<li>《编写可维护的JavaScript》 <a href="http://book.douban.com/subject/21792530/" target="_blank" rel="noopener">http://book.douban.com/subject/21792530/</a></li>
<li>悟透JavaScript <a href="http://www.cnblogs.com/leadzen/archive/2008/02/25/1073404.html" target="_blank" rel="noopener">http://www.cnblogs.com/leadzen/archive/2008/02/25/1073404.html</a></li>
<li>JavaScript秘密花园 <a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="noopener">http://bonsaiden.github.io/JavaScript-Garden/zh/</a></li>
<li>JavaScript 原理 <a href="http://typeof.net/s/jsmech/" target="_blank" rel="noopener">http://typeof.net/s/jsmech/</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2014/04/17/2014-04-17-人生RPG·睡眠和早起/" class="prev">PREV</a><a href="/2013/12/23/2013-12-23-人生RPG·马拉松/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="https://jlyu.github.io">Chain Yu</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>